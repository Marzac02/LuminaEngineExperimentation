#include "CodeGenerator.h"
#include <filesystem>
#include <fstream>
#include <StringHash.h>
#include <EASTL/algorithm.h>
#include <EASTL/string.h>
#include <EASTL/vector.h>
#include <Reflector/ReflectionCore/ReflectionDatabase.h>
#include <Reflector/Types/ReflectedType.h>
#include "Reflector/ProjectSolution.h"
#include "Reflector/ReflectionCore/ReflectedHeader.h"
#include "Reflector/ReflectionCore/ReflectedProject.h"
#include "Reflector/Types/Functions/ReflectedFunction.h"
#include "Reflector/Types/Properties/ReflectedProperty.h"


#define STREAM_INITIAL_BUFFER_SIZE 10'240 // 10 KiB

static bool IsManualReflectFile(const eastl::string& HeaderID)
{
	return HeaderID.find("manualreflecttypes") != eastl::string::npos;
}

static void GenerateFileWarning(eastl::string& Stream)
{
	Stream += "//*************************************************************************\n";
	Stream += "// Generated by Lumina Reflection Tool. \n";
	Stream += "// This is an auto-generated file - DO NOT EDIT.\n";
	Stream += "//*************************************************************************\n\n";
}

namespace Lumina::Reflection
{
	FCodeGenerator::FCodeGenerator(FReflectedWorkspace* InWorkspace, const FReflectionDatabase& Database)
		: Workspace(InWorkspace)
		, ReflectionDatabase(&Database)
	{
	}

	void FCodeGenerator::GenerateCode()
	{
		eastl::hash_map<FReflectedProject*, eastl::string> ProjectOutputs;
		eastl::hash_set<FReflectedProject*> DirtyProjects;

		for (const auto& [Header, _] : ReflectionDatabase->ReflectedTypes)
		{
			auto& Output = ProjectOutputs[Header->Project];
			if (Output.empty())
			{
				Output += "#include \"pch.h\"\n";
			}

			Output += "#include \"" + Header->FileName + ".generated.cpp\"\n";

			if (!Header->bDirty)
			{
				continue;
			}

			DirtyProjects.insert(Header->Project);

			GenerateReflectionCodeForHeader(Header);

			GenerateReflectionCodeForSource(Header);
		}

		for (auto& DirtyProject : DirtyProjects)
		{
			const eastl::string& Output = ProjectOutputs[DirtyProject];

			eastl::string ReflectionDataPath = Workspace->GetPath() + R"(\Intermediates\Reflection\)" + DirtyProject->Name + R"(\)" + "ReflectionUnity.gen.cpp";
			std::filesystem::path outputPath(ReflectionDataPath.c_str());
			std::filesystem::create_directories(outputPath.parent_path());

			std::ofstream OutputFile(ReflectionDataPath.c_str());

			if (OutputFile.is_open())
			{
				OutputFile.write(Output.c_str(), (std::streamsize)Output.size());
				OutputFile.close();
			}
		}
	}

	void FCodeGenerator::GenerateReflectionCodeForHeader(FReflectedHeader* Header)
	{
		eastl::string Stream;
		Stream.reserve(STREAM_INITIAL_BUFFER_SIZE);

		GenerateCodeHeader(Stream, Header);

		eastl::string OutFileName = Workspace->GetPath() + R"(\Intermediates\Reflection\)" + Header->Project->Name + R"(\)" + Header->FileName + ".generated.h";
		std::filesystem::path outputPath(OutFileName.c_str());
		std::filesystem::create_directories(outputPath.parent_path());

		std::ofstream OutputFile(OutFileName.c_str());

		if (OutputFile.is_open())
		{
			OutputFile.write(Stream.c_str(), Stream.size());
			OutputFile.close();
		}
	}

	void FCodeGenerator::GenerateReflectionCodeForSource(FReflectedHeader* Header)
	{
		eastl::string Stream;
		Stream.reserve(STREAM_INITIAL_BUFFER_SIZE);

		GenerateCodeSource(Stream, Header);

		eastl::string OutFileName = Workspace->GetPath() + R"(\Intermediates\Reflection\)" + Header->Project->Name + R"(\)" + Header->FileName + ".generated.cpp";
		std::filesystem::path outputPath(OutFileName.c_str());
		std::filesystem::create_directories(outputPath.parent_path());

		std::ofstream OutputFile(OutFileName.c_str());

		if (OutputFile.is_open())
		{
			OutputFile.write(Stream.c_str(), static_cast<std::streamsize>(Stream.size()));
		}
	}

	static void SanitizeFileID(eastl::string& FileID)
	{
		eastl::replace(FileID.begin(), FileID.end(), '/', '_');
		eastl::replace(FileID.begin(), FileID.end(), '\\', '_');
		eastl::replace(FileID.begin(), FileID.end(), '.', '_');
		eastl::replace(FileID.begin(), FileID.end(), '-', '_');
	}

	void FCodeGenerator::GenerateCodeHeader(eastl::string& Stream, FReflectedHeader* Header)
	{
		const eastl::vector<eastl::unique_ptr<FReflectedType>>& ReflectedTypes = ReflectionDatabase->ReflectedTypes.at(Header);

		Stream += "#pragma once\n\n";
		GenerateFileWarning(Stream);

		std::filesystem::path FullHeaderPath = Header->HeaderPath.c_str();
		std::filesystem::path SolutionRoot = Workspace->GetPath().c_str();
		std::filesystem::path RelativeHeaderPath = std::filesystem::relative(FullHeaderPath, SolutionRoot);

		Stream += "#include \"Core/Reflection/ReflectedTypeAccessors.h\"\n";

		Stream += "\n\n";

		eastl::string FileID = Header->HeaderPath;

		size_t SlashPos = FileID.find_first_of("/\\");
		if (SlashPos != eastl::string::npos)
		{
			FileID = FileID.substr(SlashPos + 1);
		}

		SanitizeFileID(FileID);

		Stream += "#ifdef " + FileID + "_generated_h\n";
		Stream += "#error Already included, missing #pragma once\n";
		Stream += "#endif\n";
		Stream += "#define " + FileID + "_generated_h\n";

		Stream += "\n\n\n";

		for (const auto& Type : ReflectedTypes)
		{
			Type->DefineInitialHeader(Stream, FileID);
		}

		Stream += "\n\n\n//--------------------------------------------------------------------------------------\n\n\n";

		for (const auto& Type : ReflectedTypes)
		{
			Type->DefineSecondaryHeader(Stream, FileID);
		}

		Stream += "\n\n\n";

		Stream += "#undef CURRENT_FILE_ID \n";
		Stream += "\t #define CURRENT_FILE_ID " + FileID + "\n";
	}

	void FCodeGenerator::GenerateCodeSource(eastl::string& Stream, FReflectedHeader* Header)
	{
		Stream.clear();

		auto TypeIt = ReflectionDatabase->ReflectedTypes.find(Header);
		const eastl::vector<eastl::unique_ptr<FReflectedType>>& ReflectedTypes = TypeIt->second;

		// Generate unique FileID from Header path
		eastl::string FileID = Header->HeaderPath;
		size_t SlashPos = FileID.find_first_of("/\\");
		if (SlashPos != eastl::string::npos)
		{
			FileID = FileID.substr(SlashPos + 1);
		}

		SanitizeFileID(FileID);


		// Preamble and Includes
		GenerateFileWarning(Stream);

		Stream += "#include \"pch.h\"\n";
		Stream += "#include \"";
		Stream += Header->HeaderPath + "\"\n";
		Stream += "#include \"World/Entity/Components/Component.h\"\n";
		Stream += "#include \"Core/Object/Class.h\"\n";
		Stream += "\n\n";

		eastl::string ProjectAPI = Header->Project->Name + "_api";
		ProjectAPI.make_upper();
		// Cross-module references
		Stream += "// Begin Cross-Module References\n";
		for (const auto& Type : ReflectedTypes)
		{
			Stream += ProjectAPI;
			Stream += " ";
			Stream += "Lumina::";
			Stream += Type->GetTypeName();
			Stream += "* Construct_";
			Stream += Type->GetTypeName();
			Stream += "_";
			if (!Type->Namespace.empty())
			{
				Stream += Type->Namespace;
				Stream += "_";
			}
			Stream += Type->DisplayName;
			Stream += "();\n";

			if (FReflectedStruct* Struct = dynamic_cast<FReflectedStruct*>(Type.get()))
			{
				for (auto& Property : Struct->Props)
				{
					if (const auto& PropType = ReflectionDatabase->GetReflectedType<FReflectedType>(FStringHash(Property->TypeName)))
					{
						eastl::string PropProjectAPI = PropType->Header->Project->Name + "_api";
						PropProjectAPI.make_upper();
						Property->DeclareCrossModuleReference(PropProjectAPI, Stream);
					}
				}
			}
		}
		Stream += "// End Cross-Module References\n\n";

		// Implementation declarations
		Stream += "//*************************************************************************\n";
		Stream += "// Type Implementations. \n";
		Stream += "//*************************************************************************\n\n";
		for (const auto& Type : ReflectedTypes)
		{
			Type->DeclareImplementation(Stream);
		}

		// Static registration
		Stream += "\n\n";
		Stream += "// ** Begin Static Registration **\n\n";

		Stream += "struct Registration_";
		Stream += FileID;
		Stream += "\n{\n";

		// EnumInfo block
		bool bHasEnums = false;
		bool bHasClass = false;
		bool bHasStruct = false;
		for (const auto& Type : ReflectedTypes)
		{
			if (Type->Type == FReflectedType::EType::Enum)
			{
				bHasEnums = true;
			}

			if (Type->Type == FReflectedType::EType::Class)
			{
				bHasClass = true;
			}

			if (Type->Type == FReflectedType::EType::Structure)
			{
				bHasStruct = true;
			}
		}

		if (bHasEnums)
		{
			Stream += "\tstatic constexpr Lumina::FEnumRegisterCompiledInInfo EnumInfo[] = {\n";
			for (const auto& Type : ReflectedTypes)
			{
				if (Type->Type == FReflectedType::EType::Enum)
				{
					Type->DeclareStaticRegistration(Stream);
				}
			}
			Stream += "\t};\n";
		}

		if (bHasClass)
		{
			Stream += "\tstatic constexpr Lumina::FClassRegisterCompiledInInfo ClassInfo[] = {\n";
			for (const auto& Type : ReflectedTypes)
			{
				if (Type->Type == FReflectedType::EType::Class)
				{
					Type->DeclareStaticRegistration(Stream);
				}
			}
			Stream += "\t};\n";
		}

		if (bHasStruct)
		{
			Stream += "\tstatic constexpr Lumina::FStructRegisterCompiledInInfo StructInfo[] = {\n";
			for (const auto& Type : ReflectedTypes)
			{
				if (Type->Type == FReflectedType::EType::Structure)
				{
					Type->DeclareStaticRegistration(Stream);
				}
			}
			Stream += "\t};\n";
		}

		Stream += "};\n";

		Stream += "static Lumina::FRegisterCompiledInInfo " + FileID + "_Register_Static_Initializer(\n";

		if (bHasEnums)
		{
			Stream += "\tRegistration_" + FileID + "::EnumInfo" + ",\n";
			Stream += "\tstd::size(Registration_" + FileID + "::EnumInfo" + "),\n";
		}
		else
		{
			Stream += "\tnullptr,\n";
			Stream += "\t0,\n";
		}

		if (bHasClass)
		{
			Stream += "\tRegistration_" + FileID + "::ClassInfo" + ",\n";
			Stream += "\tstd::size(Registration_" + FileID + "::ClassInfo" + "),\n";
		}
		else
		{
			Stream += "\tnullptr,\n";
			Stream += "\t0,\n";
		}

		if (bHasStruct)
		{
			Stream += "\tRegistration_" + FileID + "::StructInfo" + ",\n";
			Stream += "\tstd::size(Registration_" + FileID + "::StructInfo" + ")\n";
		}
		else
		{
			Stream += "\tnullptr,\n";
			Stream += "\t0\n";
		}

		Stream += ");\n\n";

		Stream += "// ** End Static Registration **\n\n";


		if (IsManualReflectFile(FileID))
		{
			return;
		}

		Stream += "// ** Begin Lua Registration **\n";
		Stream += "#include <sol/sol.hpp>\n";
		Stream += "#include \"Scripting/DeferredScriptRegistry.h\"\n";

		Stream += "static void " + FileID + "_" + "LuaRegistration(sol::state_view State)\n";
		Stream += "{\n";

		for (const auto& Type : ReflectedTypes)
		{
			if (Type->Type != FReflectedType::EType::Enum)
			{
				continue;
			}

			FReflectedEnum* Enum = static_cast<FReflectedEnum*>(Type.get());

			if (Enum->Constants.empty())
			{
				continue;
			}

			Stream += "\t State.new_enum(\"" + Type->DisplayName + "\",\n";

			for (size_t i = 0; i < Enum->Constants.size(); ++i)
			{
				const FReflectedEnum::FConstant& Constant = Enum->Constants[i];
				Stream += "\t\t\"" + Constant.Label + "\", " + Type->Namespace + "::" + Type->DisplayName + "::" + Constant.Label;

				if (i != Enum->Constants.size() - 1)
				{
					Stream += ",\n";
				}
			}

			Stream += ");";
		}

		Stream += "\n\n";

		for (const auto& Type : ReflectedTypes)
		{
			bool bIsStructure = Type->Type == FReflectedType::EType::Structure;
			bool bIsClass = Type->Type == FReflectedType::EType::Class;

			if (!(bIsClass || bIsStructure))
			{
				continue;
			}

			FReflectedStruct* StructType = static_cast<FReflectedStruct*>(Type.get());

			Stream += "\t State.new_usertype<" + Type->Namespace + "::" + Type->DisplayName + ">(\"" + Type->DisplayName + "\",\n";

			if (bIsStructure)
			{
				Stream += "\t\tsol::call_constructor, sol::constructors<" + Type->Namespace + "::" + Type->DisplayName + "()>(),\n";
			}

			if (!StructType->Parent.empty())
			{
				Stream += "\t\tsol::base_classes, sol::bases<" + Type->Namespace + "::" + StructType->Parent + ">(),\n";
			}
			Stream += "\t\t\"__type\", sol::readonly_property([]() { return \"" + Type->DisplayName + "\"; })";

			if (!Type->Props.empty() || !Type->Functions.empty())
			{
				Stream += ",";
			}

			Stream += "\n";


			for (const auto& Property : Type->Props)
			{
				if (Property->bInner)
				{
					continue;
				}

				if (Property->GenerateLuaBinding(Stream) && (Property != Type->Props.back() || !Type->Functions.empty()))
				{
					Stream += ",";
				}

				Stream += "\n";
			}

			Stream += "\n\n";

			for (const auto& Function : Type->Functions)
			{
				Stream += "\t\t\"" + Function->Name + "\", &" + Type->Namespace + "::" + Type->DisplayName + "::" + Function->Name;

				if (Function != Type->Functions.back())
				{
					Stream += ",";
				}

				Stream += "\n";
			}

			Stream += "\t);\n";

		}

		Stream += "}\n";

		Stream += "static Lumina::Scripting::FRegisterScriptInfo " + FileID + "LuaRegisterInfo(&" + FileID + "_" + "LuaRegistration);\n";


		Stream += "// ** End Lua Registration **\n\n";
	}

}